#####################################################################################
# Copyright 2016 Normation SAS
#####################################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, Version 3.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#####################################################################################

# Packages bodies

bundle common package_module_knowledge
# This common bundle defines which package modules are the defaults on different
# platforms.
{
  vars:
      # Package inventory refresh
      "query_installed_ifelapsed" string => "$(ncf_def.package_module_query_installed_ifelapsed)";
      "query_updates_ifelapsed"   string => "$(ncf_def.package_module_query_updates_ifelapsed)";

    debian::
      "platform_default" string => "apt_get";

    redhat|amazon_linux::
      "platform_default" string => "yum";

    suse|sles|opensuse::
      "platform_default" string => "zypper";

    slackware::
      "platform_default" string => "slackpkg";
}

body package_module apt_get
{
    query_installed_ifelapsed => "$(package_module_knowledge.query_installed_ifelapsed)";
    query_updates_ifelapsed => "$(package_module_knowledge.query_updates_ifelapsed)";
    #default_options =>  {};
}

body package_module zypper
{
      query_installed_ifelapsed => "$(package_module_knowledge.query_installed_ifelapsed)";
      query_updates_ifelapsed => "$(package_module_knowledge.query_updates_ifelapsed)";
      #default_options =>  {};
}

body package_module yum
# @brief Define details used when interfacing with yum
{
    query_installed_ifelapsed => "$(package_module_knowledge.query_installed_ifelapsed)";
    query_updates_ifelapsed => "$(package_module_knowledge.query_updates_ifelapsed)";
    #default_options => {};
}

body package_module slackpkg
# @brief Define details used when interfacing with slackpkg
{
      query_installed_ifelapsed => "$(package_module_knowledge.query_installed_ifelapsed)";
      query_updates_ifelapsed => "$(package_module_knowledge.query_updates_ifelapsed)";
      #default_options =>  {};
}

body package_module snap
# @brief Define details used when interfacing with snapcraft
{
    query_installed_ifelapsed => "$(package_module_knowledge.query_installed_ifelapsed)";
    query_updates_ifelapsed => "$(package_module_knowledge.query_updates_ifelapsed)";
    #default_options => {};
}

# Used in Rudder tests
body package_module test
{
      query_installed_ifelapsed => "$(ncf_def.package_module_query_installed_ifelapsed)";
      query_updates_ifelapsed => "$(ncf_def.package_module_query_updates_ifelapsed)";
      #default_options =>  {};
}

# Not upstream
body package_module zypper_pattern
{
      query_installed_ifelapsed => "$(ncf_def.package_module_query_installed_ifelapsed)";
      query_updates_ifelapsed => "$(ncf_def.package_module_query_updates_ifelapsed)";
      #default_options =>  {};
}

# Not upstream
body package_module ips
{
      query_installed_ifelapsed => "$(ncf_def.package_module_query_installed_ifelapsed)";
      query_updates_ifelapsed => "$(ncf_def.package_module_query_updates_ifelapsed)";
      #default_options =>  {};
}

# Called by package_* generic methods
bundle agent ncf_package(name, version, architecture, provider, state, options)
{
  vars:
      "class_prefix"       string => "ncf_package_${state}_${name}";

    # Build string vars used for reporting

    # State
    state_present::
      "state_description" string => "Presence";
    !state_present::
      "state_description" string => "Absence";

    # Architecture
    architecture_specified::
      "architecture_description" string => " for ${architecture} architecture ";
    !architecture_specified::
      "architecture_description" string => " ";

    # Version
    version_latest::
      "version_description" string => "in latest available version";
    !version_specified::
      "version_description" string => "in any version";
    version_specified.!version_latest::
      "version_description" string => "in version ${version}";
    
    # Log message
    pass3.!(!state_present.version_latest)::
      "message" string => "If you tried to install a virtual package, please use in place the concrete package you want to install.${const.endl}${state_description} of package ${name}${architecture_description}${version_description}",
            ifvarclass => "${report_data.method_id}_not_ok";

      "message" string => "${state_description} of package ${name}${architecture_description}${version_description}",
            ifvarclass => "!${report_data.method_id}_not_ok";
      "message" string => "Package methods using apt, yum, zypper and zypper_pattern require Python (2 or 3) present on the system to work.${const.endl}${state_description} of package ${name}${architecture_description}${version_description}",
                    if => "!_have_python.(use_apt_provider|use_yum_provider|use_zypper_provider|use_zypper_pattern_provider)";

    !state_present.version_latest::
      "message" string => "${state_description} of package ${name}${architecture_description}${version_description} is not supported and";

  defaults:
      "version"      string => "any", if_match_regex => "";
      "architecture" string => "default", if_match_regex => "";
      "provider"     string => "default", if_match_regex => "";
      # Select the default packager for this platform if "default"
      "provider"     string => "${package_module_knowledge.platform_default}", if_match_regex => "default";
      "state"        string => "present", if_match_regex => "";

  classes:
      "version_latest"  expression => strcmp("latest", "${version}");
      # As "latest" is understood by package promises,
      # the only special case is "any", which maps to
      # no specified version in the promise
      "version_specified"      not => strcmp("any", "${version}");

      "state_present" expression => strcmp("present", "${state}");

      # If architecture is not specified, do not add it to the promise.
      # The package module will pick the default one for the local platform
      "architecture_specified" not => strcmp("default", "${architecture}");

      # Select the right package manager
      # The default one has already been selected if needed using mackage_module_knowledge
      # use both apt to be compatible with generic method and apt_get for compatibility with knowledge
      "use_apt_provider" expression => strcmp("apt_get", "${provider}");
      "use_apt_provider" expression => strcmp("apt", "${provider}");
      "use_yum_provider" expression => strcmp("yum", "${provider}");
      "use_zypper_provider" expression => strcmp("zypper", "${provider}");
      "use_zypper_pattern_provider" expression => strcmp("zypper_pattern", "${provider}");
      "use_pkg_provider" expression => strcmp("pkg", "${provider}");
      "use_slackpkg_provider" expression => strcmp("slackpkg", "${provider}");
      "use_ips_provider" expression => strcmp("ips", "${provider}");
      "use_nimclient_provider" expression => strcmp("nimclient", "${provider}");
      "use_snap_provider" expression => strcmp("snap", "${provider}");
      # Used in tests
      "use_test_provider" expression => strcmp("test", "${provider}");

    any::
      "supported_provider" expression => "use_apt_provider|use_yum_provider|use_zypper_provider|use_pkg_provider|use_slackpkg_provider|use_test_provider|use_zypper_pattern_provider|use_ips_provider|use_nimclient_provider|use_snap_provider";

      "pass3" expression => "pass2";
      "pass2" expression => "pass1";
      "pass1" expression => "any";

  packages:

    # Unfortunately, we have to duplicate the 4 cases for each supported package module
    
    #### apt ####

    use_apt_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => apt_get,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_apt_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => apt_get,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_apt_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => apt_get,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_apt_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => apt_get,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    #### yum ####

    use_yum_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => yum,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_yum_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => yum,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_yum_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => yum,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_yum_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => yum,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    #### zypper ####

    use_zypper_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => zypper,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_zypper_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => zypper,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_zypper_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => zypper,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_zypper_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => zypper,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    #### zypper-pattern ####

    use_zypper_pattern_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => zypper_pattern,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_zypper_pattern_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => zypper_pattern,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_zypper_pattern_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => zypper_pattern,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_zypper_pattern_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => zypper_pattern,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    #### pkg ####

    use_pkg_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => pkg,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_pkg_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => pkg,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_pkg_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => pkg,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_pkg_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => pkg,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    #### slackpkg ####

    use_slackpkg_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => slackpkg,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_slackpkg_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => slackpkg,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_slackpkg_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => slackpkg,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_slackpkg_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => slackpkg,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

     #### ips ####

    use_ips_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => ips,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_ips_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => ips,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_ips_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => ips,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_ips_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => ips,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    #### nimclient ####
 
    use_nimclient_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => nimclient,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_nimclient_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => nimclient,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_nimclient_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => nimclient,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_nimclient_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => nimclient,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");


    #### snap ####

    use_snap_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => snap,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_snap_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => snap,
          architecture   => "${architecture}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_snap_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => snap,
          version        => "${version}",
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_snap_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => snap,
          options        => { "${options}" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");


    #### test ####

    use_test_provider.architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => test,
          architecture   => "${architecture}",
          version        => "${version}",
          options        => { "test_db" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_test_provider.architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => test,
          architecture   => "${architecture}",
          options        => { "test_db" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_test_provider.!architecture_specified.version_specified::
      "${name}"
          policy         => "${state}",
          package_module => test,
          version        => "${version}",
          options        => { "test_db" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

    use_test_provider.!architecture_specified.!version_specified::
      "${name}"
          policy         => "${state}",
          package_module => test,
          options        => { "test_db" },
          classes        => classes_generic_two("${report_data.method_id}", "${class_prefix}");

  methods:
    !supported_provider::
      "force failure class" usebundle => _classes_failure("${class_prefix}");
      "force failure class" usebundle => _classes_failure("${report_data.method_id}");
}

#### Old package promises

# DEPRECATED
bundle common rudder_debian_knowledge
# @depends paths
# @brief common Rudder Debian knowledge bundle
#
# This common bundle has useful information about Debian.
{
  vars:
      "dpkg_compare_equal" string => "/usr/bin/dpkg --compare-versions '${v1}' eq '${v2}'";
      "dpkg_compare_less"  string => "/usr/bin/dpkg --compare-versions '${v1}' lt '${v2}'";
}

# DEPRECATED
bundle common rudder_rpm_knowledge
# @depends paths
# @brief common Rudder RPM knowledge bundle
#
# This common bundle has useful information about platforms using RPM
{
  vars:
      "rpm_compare_equal" string => "${sys.workdir}/bin/rpmvercmp '${v1}' eq '${v2}'";
      "rpm_compare_less"  string => "${sys.workdir}/bin/rpmvercmp '${v1}' lt '${v2}'";

}

# DEPRECATED
body package_method yum_rpm_no_version
{
    package_changes => "bulk";
    package_list_command => "/bin/rpm -qa --qf '%{name}.%{arch} %{version}-%{release}\n'";
    package_patch_list_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";

    package_list_name_regex    => "([^.]+).*";
    package_list_version_regex => "[^\s]\s+([^\s]+).*";
    package_list_arch_regex    => "[^.]+\.([^\s]+).*";

    package_installed_regex => ".*";
    package_name_convention => "$(name)";

    # just give the package name to rpm to delete, otherwise it gets "name.*" (from package_name_convention above)
    package_delete_convention => "$(name)";

    # set it to "0" to avoid caching of list during upgrade
    package_list_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";

    package_patch_installed_regex => "^\s.*";
    package_patch_name_regex    => "([^.]+).*";
    package_patch_version_regex => "[^\s]\s+([^\s]+).*";
    package_patch_arch_regex    => "[^.]+\.([^\s]+).*";


    package_add_command    => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) -y install";
    package_update_command => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) -y update";
    package_patch_command  => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) -y update";
    package_delete_command => "$(rpm_knowledge.call_rpm) -e --nodeps";
    package_verify_command => "$(rpm_knowledge.call_rpm) -V";
    package_noverify_returncode => "1";
    package_version_less_command => "$(redhat_knowledge.rpm_compare_less)";
    package_version_equal_command => "$(redhat_knowledge.rpm_compare_equal)";
}

# Install packages using yum localinstall, disable package caching
# DEPRECATED
body package_method redhat_local_install
{
  redhat::
    package_changes => "bulk";
    package_list_command => "/bin/rpm -qa --qf '%{name} %{version}-%{release} %{arch}\n'";
    package_patch_list_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_name_regex    => "^(\S+?)\s\S+?\s\S+$";
    package_list_version_regex => "^\S+?\s(\S+?)\s\S+$";
    package_list_arch_regex    => "^\S+?\s\S+?\s(\S+)$";
    package_installed_regex => ".*";
    package_name_convention => "$(name)";
    package_list_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_patch_installed_regex => "^\s.*";
    package_patch_name_regex    => "([^.]+).*";
    package_patch_version_regex => "[^\s]\s+([^\s]+).*";
    package_patch_arch_regex    => "[^.]+\.([^\s]+).*";
    package_add_command    => "/usr/bin/yum ${redhat_knowledge.yum_options} -y localinstall";
    package_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_patch_command => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_delete_command => "/bin/rpm -e --nodeps --allmatches";
    package_verify_command => "/bin/rpm -V";
    package_noverify_returncode => "1";
    package_version_less_command => "$(redhat_knowledge.rpm_compare_less)";
    package_version_equal_command => "$(redhat_knowledge.rpm_compare_equal)";
}
# Install packages using yum standard install, disable package caching
# DEPRECATED
body package_method redhat_install
{
  redhat::
    package_changes => "bulk";
    package_list_command => "/bin/rpm -qa --qf '%{name} %{version}-%{release} %{arch}\n'";
    package_patch_list_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_name_regex    => "^(\S+?)\s\S+?\s\S+$";
    package_list_version_regex => "^\S+?\s(\S+?)\s\S+$";
    package_list_arch_regex    => "^\S+?\s\S+?\s(\S+)$";
    package_installed_regex => ".*";
    package_name_convention => "$(name)";
    package_list_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_patch_installed_regex => "^\s.*";
    package_patch_name_regex    => "([^.]+).*";
    package_patch_version_regex => "[^\s]\s+([^\s]+).*";
    package_patch_arch_regex    => "[^.]+\.([^\s]+).*";
    package_add_command    => "/usr/bin/yum ${redhat_knowledge.yum_options} -y install";
    package_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_patch_command => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_delete_command => "/bin/rpm -e --nodeps --allmatches";
    package_verify_command => "/bin/rpm -V";
    package_noverify_returncode => "1";
    package_version_less_command => "$(redhat_knowledge.rpm_compare_less)";
    package_version_equal_command => "$(redhat_knowledge.rpm_compare_equal)";
}

# DEPRECATED
body package_method debian_local_install
{
    package_changes => "individual";
    package_list_command => "$(debian_knowledge.call_dpkg) -l";
    # set it to "0" to avoid caching of list during upgrade
    package_list_update_command => "$(debian_knowledge.call_apt_get) update";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_list_name_regex    => ".i\s+([^\s]+).*";
    package_list_version_regex => ".i\s+[^\s]+\s+([^\s]+).*";
    package_installed_regex => ".i.*"; # packages that have been uninstalled may be listed
    package_file_repositories => { "$(repo)" };
    package_add_command => "$(debian_knowledge.call_dpkg) --install";
    package_delete_command => "$(debian_knowledge.call_dpkg) --purge";
    package_update_command =>  "$(debian_knowledge.call_dpkg) --install";
    package_patch_command =>  "$(debian_knowledge.call_dpkg) --install";

    # make correct version comparisons
    package_version_less_command => "$(debian_knowledge.dpkg_compare_less)";
    package_version_equal_command => "$(debian_knowledge.dpkg_compare_equal)";

  x86_64::
    package_name_convention => "$(name)_$(version)_amd64.deb";
  i686::
    package_name_convention => "$(name)_$(version)_i386.deb";
  have_aptitude::
    package_patch_list_command => "/usr/bin/aptitude --assume-yes --simulate --verbose full-upgrade";
    package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
    package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";
  !have_aptitude::
    package_patch_list_command => "$(debian_knowledge.call_apt_get) --just-print dist-upgrade";
    package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
    package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";
}

# DEPRECATED
body package_method ncf_generic
{
  SuSE::
    package_changes => "bulk";
    package_list_command => "/bin/rpm -qa --queryformat \"i | repos | %{name} | %{version}-%{release} | %{arch}\n\"";
    # set it to "0" to avoid caching of list during upgrade
    package_list_update_command => "/usr/bin/zypper --non-interactive refresh";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_installed_regex => "i.*";
    package_list_name_regex    => "[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_list_version_regex => "[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_list_arch_regex    => "[^|]+\|[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_patch_name_regex    => "[^|]+\|\s+([^\s]+).*";
    package_patch_version_regex => "[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_name_convention => "$(name)";
    package_add_command => "/usr/bin/zypper --non-interactive install";
    package_delete_command => "/usr/bin/zypper --non-interactive remove --force-resolution";
    package_update_command => "/usr/bin/zypper --non-interactive update";
    package_patch_command => "/usr/bin/zypper --non-interactive patch$"; # $ means no args
    package_verify_command => "/usr/bin/zypper --non-interactive verify$";

  redhat::
    package_changes => "bulk";
    package_list_command => "/bin/rpm -qa --qf '%{name} %{version}-%{release} %{arch}\n'";
    package_patch_list_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_name_regex    => "^(\S+?)\s\S+?\s\S+$";
    package_list_version_regex => "^\S+?\s(\S+?)\s\S+$";
    package_list_arch_regex    => "^\S+?\s\S+?\s(\S+)$";
    package_installed_regex => ".*";
    package_name_convention => "$(name)";
    package_list_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_patch_installed_regex => "^\s.*";
    package_patch_name_regex    => "([^.]+).*";
    package_patch_version_regex => "[^\s]\s+([^\s]+).*";
    package_patch_arch_regex    => "[^.]+\.([^\s]+).*";
    package_add_command    => "/usr/bin/yum ${redhat_knowledge.yum_options} -y install";
    package_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_patch_command => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_delete_command => "/bin/rpm -e --nodeps --allmatches";
    package_verify_command => "/bin/rpm -V";
    package_version_less_command => "$(redhat_knowledge.rpm_compare_less)";
    package_version_equal_command => "$(redhat_knowledge.rpm_compare_equal)";

  debian::
    package_changes => "bulk";
    package_list_command => "$(debian_knowledge.call_dpkg) -l";
    package_list_name_regex    => ".i\s+([^\s:]+).*";
    package_list_version_regex => ".i\s+[^\s]+\s+([^\s]+).*";
    package_installed_regex => ".i.*"; # packages that have been uninstalled may be listed
    package_name_convention => "$(name)";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";

    # make correct version comparisons
    package_version_less_command => "$(debian_knowledge.dpkg_compare_less)";
    package_version_equal_command => "$(debian_knowledge.dpkg_compare_equal)";

  debian.have_aptitude::
    package_add_command => "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
    package_list_update_command => "/usr/bin/aptitude update";
    package_delete_command => "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes remove";
    package_update_command =>  "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
    package_patch_command =>  "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
    package_verify_command =>  "/usr/bin/aptitude show";
    package_noverify_regex => "(State: not installed|E: Unable to locate package .*)";

    package_patch_list_command => "/usr/bin/aptitude --assume-yes --simulate --verbose full-upgrade";
    package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
    package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";

  debian.!have_aptitude::
    package_add_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_list_update_command => "$(debian_knowledge.call_apt_get) update";
    package_delete_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes remove";
    package_update_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_patch_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_verify_command => "$(debian_knowledge.call_dpkg) -s";
    package_noverify_returncode => "1";

    package_patch_list_command => "$(debian_knowledge.call_apt_get) --just-print dist-upgrade";
    package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
    package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";
}

# Same as ncf_generic with version in package name
# DEPRECATED
body package_method ncf_generic_version
{
  SuSE::
    package_changes => "bulk";
    package_list_command => "/bin/rpm -qa --queryformat \"i | repos | %{name} | %{version}-%{release} | %{arch}\n\"";
    # set it to "0" to avoid caching of list during upgrade
    package_list_update_command => "/usr/bin/zypper --non-interactive refresh";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_installed_regex => "i.*";
    package_list_name_regex    => "[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_list_version_regex => "[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_list_arch_regex    => "[^|]+\|[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_patch_name_regex    => "[^|]+\|\s+([^\s]+).*";
    package_patch_version_regex => "[^|]+\|[^|]+\|\s+([^\s]+).*";
    package_name_convention => "$(name)=$(version)";
    package_add_command => "/usr/bin/zypper --non-interactive install";
    package_delete_command => "/usr/bin/zypper --non-interactive remove --force-resolution";
    package_update_command => "/usr/bin/zypper --non-interactive update";
    package_patch_command => "/usr/bin/zypper --non-interactive patch$"; # $ means no args
    package_verify_command => "/usr/bin/zypper --non-interactive verify$";

  redhat::
    package_changes => "bulk";
    package_list_command => "/bin/rpm -qa --qf '%{name} %{version}-%{release} %{arch}\n'";
    package_patch_list_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_name_regex    => "^(\S+?)\s\S+?\s\S+$";
    package_list_version_regex => "^\S+?\s(\S+?)\s\S+$";
    package_list_arch_regex    => "^\S+?\s\S+?\s(\S+)$";
    package_installed_regex => ".*";
    package_name_convention => "$(name)-$(version)";
    package_list_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} check-update";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
    package_patch_installed_regex => "^\s.*";
    package_patch_name_regex    => "([^.]+).*";
    package_patch_version_regex => "[^\s]\s+([^\s]+).*";
    package_patch_arch_regex    => "[^.]+\.([^\s]+).*";
    package_add_command    => "/usr/bin/yum ${redhat_knowledge.yum_options} -y install";
    package_update_command => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_patch_command => "/usr/bin/yum ${redhat_knowledge.yum_options} -y update";
    package_delete_command => "/bin/rpm -e --nodeps --allmatches";
    package_verify_command => "/bin/rpm -V";
    package_version_less_command => "$(redhat_knowledge.rpm_compare_less)";
    package_version_equal_command => "$(redhat_knowledge.rpm_compare_equal)";

  debian::
    package_changes => "bulk";
    package_list_command => "$(debian_knowledge.call_dpkg) -l";
    package_list_name_regex    => ".i\s+([^\s:]+).*";
    package_list_version_regex => ".i\s+[^\s]+\s+([^\s]+).*";
    package_installed_regex => ".i.*"; # packages that have been uninstalled may be listed
    package_name_convention => "$(name)=$(version)";
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";

    # make correct version comparisons
    package_version_less_command => "$(debian_knowledge.dpkg_compare_less)";
    package_version_equal_command => "$(debian_knowledge.dpkg_compare_equal)";


  debian.have_aptitude::
    package_add_command => "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
    package_list_update_command => "/usr/bin/aptitude update";
    package_delete_command => "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes remove";
    package_update_command =>  "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
    package_patch_command =>  "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
    package_verify_command =>  "/usr/bin/aptitude show";
    package_noverify_regex => "(State: not installed|E: Unable to locate package .*)";

    package_patch_list_command => "/usr/bin/aptitude --assume-yes --simulate --verbose full-upgrade";
    package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
    package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";

  debian.!have_aptitude::
    package_add_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_list_update_command => "$(debian_knowledge.call_apt_get) update";
    package_delete_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes remove";
    package_update_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_patch_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_verify_command => "$(debian_knowledge.call_dpkg) -s";
    package_noverify_returncode => "1";

    package_patch_list_command => "$(debian_knowledge.call_apt_get) --just-print dist-upgrade";
    package_patch_name_regex => "^Inst\s+(\S+)\s+.*";
    package_patch_version_regex => "^Inst\s+\S+\s+\[?\(?([^\],\s]+).*";
 }

# Same as apt_get from CFEngine lib with version in package name
# DEPRECATED
body package_method apt_get_version
{
    package_changes => "bulk";
    package_list_command => "$(debian_knowledge.call_dpkg) -l";
    package_list_name_regex => "$(debian_knowledge.list_name_regex)";
    package_list_version_regex => "$(debian_knowledge.list_version_regex)";
    package_installed_regex => ".i.*"; # packages that have been uninstalled may be listed
    package_name_convention => "$(name)=$(version)";

    # set it to "0" to avoid caching of list during upgrade
    package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";

    # Target a specific release, such as backports
    package_add_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_list_update_command => "$(debian_knowledge.call_apt_get) update";
    package_delete_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes -q remove";
    package_update_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_patch_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
    package_verify_command => "$(debian_knowledge.call_dpkg) -s";
    package_noverify_returncode => "1";

    package_patch_list_command => "$(debian_knowledge.call_apt_get) --just-print dist-upgrade";
    package_patch_name_regex => "$(debian_knowledge.patch_name_regex)";
    package_patch_version_regex => "$(debian_knowledge.patch_version_regex)";

    # make correct version comparisons
    package_version_less_command => "$(debian_knowledge.dpkg_compare_less)";
    package_version_equal_command => "$(debian_knowledge.dpkg_compare_equal)";
}

bundle common common_knowledge
# @brief common packages knowledge bundle
#
# This common bundle defines general things about platforms.
{
  vars:
      "list_update_ifelapsed" string => "${node.properties[rudder][packages][updates_cache_expire]}";
}

bundle common debian_knowledge
# @depends paths
# @brief common Debian knowledge bundle
#
# This common bundle has useful information about Debian.
{
  vars:
      # Debian default package architecture, see https://wiki.debian.org/Multiarch/Tuples
      "default_arch" string => ifelse("x86_64", "amd64",
                                      "i386", "i386",
                                      $(sys.arch));

      "apt_prefix" string => "/usr/bin/env DEBIAN_FRONTEND=noninteractive LC_ALL=C PATH=/bin:/sbin/:/usr/bin:/usr/sbin";
      "call_dpkg" string => "$(apt_prefix) $(paths.path[dpkg])";
      "call_apt_get" string => "$(apt_prefix) $(paths.path[apt_get])";
      "call_aptitude" string => "$(apt_prefix) $(paths.path[aptitude])";
      "dpkg_options" string => "-o Dpkg::Options::=--force-confold -o Dpkg::Options::=--force-confdef";

      "dpkg_compare_equal" string => "$(call_dpkg) --compare-versions '$(v1)' eq '$(v2)'";
      "dpkg_compare_less" string => "$(call_dpkg) --compare-versions '$(v1)' lt '$(v2)'";

      "list_name_regex" string => "^.i\s+([^\s:]+).*";
      "list_version_regex" string => "^.i\s+[^\s]+\s+([^\s]+).*";

      "patch_name_regex" string => "^Inst\s+(\S+)\s+.*";
      "patch_version_regex" string => "^Inst\s+\S+\s+\[\S+\]\s+\((\S+)\s+.*";
}

bundle common rpm_knowledge
# @depends paths
# @brief common RPM knowledge bundle
#
# This common bundle has useful information about platforms using RPM
{
  vars:
      "call_rpm" string => "$(paths.rpm)";

      "rpm_output_format" string => "i | repos | %{name} | %{version}-%{release} | %{arch}\n";
      "rpm_name_regex" string => "[^|]+\|[^|]+\|\s+([^\s|]+).*";
      "rpm_version_regex" string => "[^|]+\|[^|]+\|[^|]+\|\s+([^\s|]+).*";
      "rpm_arch_regex" string => "[^|]+\|[^|]+\|[^|]+\|[^|]+\|\s+([^\s]+).*";

      "rpm2_output_format" string => "%{name} %{version}-%{release} %{arch}\n";
      "rpm2_name_regex" string => "^(\S+?)\s\S+?\s\S+$";
      "rpm2_version_regex" string => "^\S+?\s(\S+?)\s\S+$";
      "rpm2_arch_regex" string => "^\S+?\s\S+?\s(\S+)$";

      "rpm3_output_format" string => "%{name} %{arch} %{version}-%{release}\n";
      "rpm3_name_regex" string => "(\S+).*";
      "rpm3_version_regex" string => "\S+\s+\S+\s+(\S+).*";
      "rpm3_arch_regex" string => "\S+\s+(\S+).*";
}

bundle common redhat_no_locking_knowledge {
  vars:
    # Option was introduced in rhel 6.1
    (amazon_linux|redhat|centos).!(redhat_3|redhat_4|redhat_5|redhat_6_0|centos_3|centos_4|centos_5|centos_6_0)::
      "no_locking_option" string => "--setopt=exit_on_lock=True";
    redhat_3|redhat_4|redhat_5|redhat_6_0|centos_3|centos_4|centos_5|centos_6_0::
      "no_locking_option" string => "";
}

bundle common redhat_knowledge
# @depends paths
# @brief common Red Hat knowledge bundle
#
# This common bundle has useful information about Red Hat and its
# derivatives
{
  vars:
      # Red Hat default package architecture
      "default_arch" string => $(sys.arch);

      "call_yum" string => "$(paths.path[yum])";
      "call_rpmvercmp" string => "$(sys.bindir)/rpmvercmp";

      # on RHEL 3/4, Yum doesn't know how to be --quiet
      "yum_options" string => ifelse("centos_4|redhat_4|centos_3|redhat_3", "",
                                     "--quiet ${redhat_no_locking_knowledge.no_locking_option}");
      "yum_offline_options" string => "$(yum_options) -C";

      "rpm_compare_equal" string => "$(call_rpmvercmp) '$(v1)' eq '$(v2)'";
      "rpm_compare_less" string => "$(call_rpmvercmp)  '$(v1)' lt '$(v2)'";
      # yum check-update prints a lot of extra useless lines, but the format of
      # the actual package lines is:
      #
      #   <name>.<arch>    <version>    <repo>
      #
      # We try to match that format as closely as possible, so we reject
      # possibly interspersed error messages.
      "patch_name_regex" string    => "^(\S+)\.[^\s.]+\s+\S+\s+\S+\s*$";
      "patch_version_regex" string => "^\S+\.[^\s.]+\s+(\S+)\s+\S+\s*$";
      "patch_arch_regex" string    => "^\S+\.([^\s.]+)\s+\S+\s+\S+\s*$";

      # Combine multiline entries into one line. A line without at least three
      # fields gets combined with the next line, if that line starts with a
      # space.
      "check_update_postproc" string => "| $(paths.sed) -r -n -e '
        :begin;
        /\S+\s+\S+\s+\S+/!{    # Check for valid line.
            N;                 # If not, read in the next line and append it.
            /\n /!{            # Check whether that line started with a space.
                h;             # If not, copy buffer to clipboard.
                s/\n[^\n]*$//; # Erase last line.
                p;             # Print current buffer.
                x;             # Restore from clipboard.
                s/^.*\n//;     # Erase everything but last line.
            };
            s/\n / /;          # Combine lines by removing newline.
            bbegin;            # Jump back to begin.
        };
        p;                     # Print current buffer.'";
}

bundle common suse_knowledge
# @depends paths
# @brief common SUSE knowledge bundle
{
  vars:
      # SUSE default package architecture
      "default_arch" string => $(sys.arch);

      "call_zypper" string => "$(paths.zypper)";
}


# Ignore aptitude because:
#  1) aptitude will remove "unneeded" packages unexpectly
#  2) aptitude return codes are useless
#  3) aptitude is a high level interface
#  4) aptitude provides little benefit
#  5) have_aptitude is a hard class and thus cannot be unset
body package_method apt_get
# @depends common_knowledge debian_knowledge
# @brief APT installation package method
#
# This package method interacts with the APT package manager through `apt-get`.
#
# **Example:**
#
# ```cf3
# packages:
#     "mypackage" package_method => apt_get, package_policy => "add";
# ```
{
      package_changes => "bulk";
      package_list_command => "$(debian_knowledge.call_dpkg) -l";
      package_list_name_regex => "$(debian_knowledge.list_name_regex)";
      package_list_version_regex => "$(debian_knowledge.list_version_regex)";
      package_installed_regex => ".i.*"; # packages that have been uninstalled may be listed
      package_name_convention => "$(name)=$(version)";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";

      # Target a specific release, such as backports
      package_add_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_list_update_command => "$(debian_knowledge.call_apt_get) update";
      package_delete_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes -q remove";
      package_update_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_patch_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_verify_command => "$(debian_knowledge.call_dpkg) -s";
      package_noverify_returncode => "1";

      package_patch_list_command => "$(debian_knowledge.call_apt_get) --just-print dist-upgrade";
      package_patch_name_regex => "$(debian_knowledge.patch_name_regex)";
      package_patch_version_regex => "$(debian_knowledge.patch_version_regex)";

      # make correct version comparisons
      package_version_less_command => "$(debian_knowledge.dpkg_compare_less)";
      package_version_equal_command => "$(debian_knowledge.dpkg_compare_equal)";
}

##

body package_method yum_rpm
# @depends common_knowledge rpm_knowledge redhat_knowledge
# @brief Yum+RPM installation method
#
# This package method interacts with the Yum and RPM package managers.
#
# Contributed by Trond Hasle Amundsen
#
# This is an efficient package method for RPM-based systems - uses `rpm`
# instead of `yum` to list installed packages.
#
# It will use `rpm -e` to remove packages. Please note that if several packages
# with the same name but varying versions or architectures are installed,
# `rpm -e` will return an error and not delete any of them.
#
# **Example:**
#
# ```cf3
# packages:
#     "mypackage" package_method => yum_rpm, package_policy => "add";
# ```
{
      package_changes => "bulk";
      package_list_command => "$(rpm_knowledge.call_rpm) -qa --qf '$(rpm_knowledge.rpm3_output_format)'";
      package_patch_list_command => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_offline_options) check-update $(redhat_knowledge.check_update_postproc)";

      package_list_name_regex    => "$(rpm_knowledge.rpm3_name_regex)";
      package_list_version_regex => "$(rpm_knowledge.rpm3_version_regex)";
      package_list_arch_regex    => "$(rpm_knowledge.rpm3_arch_regex)";

      package_installed_regex => ".*";
      package_name_convention => "$(name)-$(version).$(arch)";

      # just give the package name to rpm to delete, otherwise it gets "name.*" (from package_name_convention above)
      package_delete_convention => "$(name)";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_command => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) check-update $(redhat_knowledge.check_update_postproc)";
      package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";

      package_patch_name_regex    => "$(redhat_knowledge.patch_name_regex)";
      package_patch_version_regex => "$(redhat_knowledge.patch_version_regex)";
      package_patch_arch_regex    => "$(redhat_knowledge.patch_arch_regex)";

      package_add_command    => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) -y install";
      package_update_command => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) -y update";
      package_patch_command  => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) -y update";
      package_delete_command => "$(rpm_knowledge.call_rpm) -e --nodeps";
      package_verify_command => "$(rpm_knowledge.call_rpm) -V";
      package_noverify_returncode => "1";
      package_version_less_command => "$(redhat_knowledge.rpm_compare_less)";
      package_version_equal_command => "$(redhat_knowledge.rpm_compare_equal)";
}

body package_method yum_rpm_permissive
# @depends common_knowledge rpm_knowledge redhat_knowledge
# @brief Yum+RPM permissive (just by name) package method
#
# This package method interacts with the Yum and RPM package managers.
#
# Copy of yum_rpm which was contributed by Trond Hasle Amundsen
#
# This is an efficient package method for RPM-based systems - uses
# `rpm` instead of `yum` to list installed packages. It can't delete
# packages and can't take a target version or architecture, so only
# the "add" and "addupdate" methods should be used.
#
# Normally you have to specify the package version, and it defaults to
# `*`, which then triggers the bug of installing `xyz-abc` when you ask for `xyz`.
#
# This "permissive" body sets
#
#    package_name_convention => "$(name)";
#
# which is permissive in the sense of not requiring the version.
#
##
##

body package_method rpm_filebased(path)
# @depends common_knowledge rpm_knowledge redhat_knowledge
# @brief install packages from local filesystem-based RPM repository.
# @param path the path to the local package repository
#
# Contributed by Aleksey Tsalolikhin. Written on 29-Feb-2012.
# Based on `yum_rpm()` body by Trond Hasle Amundsen.
#
# **Example:**
#
# ```cf3
# packages:
#     "epel-release"
#     package_policy => "add",
#     package_version => "5-4",
#     package_architectures => { "noarch" },
#     package_method => rpm_filebased("/repo/RPMs");
# ```
{

body package_method generic
# @depends paths common_knowledge debian_knowledge rpm_knowledge redhat_knowledge
# @brief Generic installation package method
#
# This package method attempts to handle all platforms.
#
# The Redhat section is a verbatim insertion of `yum_rpm()`, which was
# contributed by Trond Hasle Amundsen.
#
# **Example:**
#
# ```cf3
# packages:
#     "mypackage" package_method => generic, package_policy => "add";
# ```
{
    suse|sles|opensuse::
      package_changes => "bulk";
      package_list_command => "$(rpm_knowledge.call_rpm) -qa --queryformat \"$(rpm_knowledge.rpm_output_format)\"";
      # set it to "0" to avoid caching of list during upgrade
      package_list_update_command => "$(suse_knowledge.call_zypper) list-updates";
      package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";
      package_patch_list_command => "$(suse_knowledge.call_zypper) patches";
      package_installed_regex => "i.*";
      package_list_name_regex    => "$(rpm_knowledge.rpm_name_regex)";
      package_list_version_regex => "$(rpm_knowledge.rpm_version_regex)";
      package_list_arch_regex    => "$(rpm_knowledge.rpm_arch_regex)";
      package_patch_installed_regex => ".*Installed.*|.*Not Applicable.*";
      package_patch_name_regex    => "[^|]+\|\s+([^\s]+).*";
      package_patch_version_regex => "[^|]+\|[^|]+\|\s+([^\s]+).*";
      package_name_convention => "$(name)";
      package_add_command => "$(suse_knowledge.call_zypper) --non-interactive install";
      package_delete_command => "$(suse_knowledge.call_zypper) --non-interactive remove --force-resolution";
      package_update_command => "$(suse_knowledge.call_zypper) --non-interactive update";
      package_patch_command => "$(suse_knowledge.call_zypper) --non-interactive patch$"; # $ means no args
      package_verify_command => "$(suse_knowledge.call_zypper) --non-interactive verify$";

    redhat::
      package_changes => "bulk";
      package_list_command => "$(rpm_knowledge.call_rpm) -qa --qf '$(rpm_knowledge.rpm3_output_format)'";
      package_patch_list_command => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_offline_options) check-update $(redhat_knowledge.check_update_postproc)";

      package_list_name_regex    => "$(rpm_knowledge.rpm3_name_regex)";
      package_list_version_regex => "$(rpm_knowledge.rpm3_version_regex)";
      package_list_arch_regex    => "$(rpm_knowledge.rpm3_arch_regex)";

      package_installed_regex => ".*";
      package_name_convention => "$(name)-$(version).$(arch)";

      # just give the package name to rpm to delete, otherwise it gets "name.*" (from package_name_convention above)
      package_delete_convention => "$(name)";

      # set it to "0" to avoid caching of list during upgrade
      package_list_update_command => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) check-update $(redhat_knowledge.check_update_postproc)";
      package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";

      package_patch_name_regex    => "$(redhat_knowledge.patch_name_regex)";
      package_patch_version_regex => "$(redhat_knowledge.patch_version_regex)";
      package_patch_arch_regex    => "$(redhat_knowledge.patch_arch_regex)";

      package_add_command    => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) -y install";
      package_update_command => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) -y update";
      package_patch_command  => "$(redhat_knowledge.call_yum) $(redhat_knowledge.yum_options) -y update";
      package_delete_command => "$(rpm_knowledge.call_rpm) -e --nodeps";
      package_verify_command => "$(rpm_knowledge.call_rpm) -V";
      package_noverify_returncode => "1";
      package_version_less_command => "$(redhat_knowledge.rpm_compare_less)";
      package_version_equal_command => "$(redhat_knowledge.rpm_compare_equal)";

    debian::
      package_changes => "bulk";
      package_list_command => "$(debian_knowledge.call_dpkg) -l";
      package_list_name_regex => "$(debian_knowledge.list_name_regex)";
      package_list_version_regex => "$(debian_knowledge.list_version_regex)";
      package_installed_regex => ".i.*"; # packages that have been uninstalled may be listed
      package_name_convention => "$(name)";
      package_list_update_ifelapsed => "$(common_knowledge.list_update_ifelapsed)";

      # make correct version comparisons
      package_version_less_command => "$(debian_knowledge.dpkg_compare_less)";
      package_version_equal_command => "$(debian_knowledge.dpkg_compare_equal)";

    debian.have_aptitude::
      package_add_command => "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
      package_list_update_command => "$(debian_knowledge.call_aptitude) update";
      package_delete_command => "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes remove";
      package_update_command =>  "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
      package_patch_command =>  "$(debian_knowledge.call_aptitude) $(debian_knowledge.dpkg_options) --assume-yes install";
      package_verify_command =>  "$(debian_knowledge.call_aptitude) show";
      package_noverify_regex => "(State: not installed|E: Unable to locate package .*)";

      package_patch_list_command => "$(debian_knowledge.call_aptitude) --assume-yes --simulate --verbose full-upgrade";
      package_patch_name_regex => "$(debian_knowledge.patch_name_regex)";
      package_patch_version_regex => "$(debian_knowledge.patch_version_regex)";

    debian.!have_aptitude::
      package_add_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_list_update_command => "$(debian_knowledge.call_apt_get) update";
      package_delete_command => "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes remove";
      package_update_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_patch_command =>  "$(debian_knowledge.call_apt_get) $(debian_knowledge.dpkg_options) --yes install";
      package_verify_command => "$(debian_knowledge.call_dpkg) -s";
      package_noverify_returncode => "1";

      package_patch_list_command => "$(debian_knowledge.call_apt_get) --just-print dist-upgrade";
      package_patch_name_regex => "$(debian_knowledge.patch_name_regex)";
      package_patch_version_regex => "$(debian_knowledge.patch_version_regex)";
 }
