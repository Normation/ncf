# Common bodies

##-------------------------------------------------------
## action
##-------------------------------------------------------

##

body action if_elapsed_day
# @brief Evalute the promise once every 24 hours
{
      ifelapsed => "1440";    # 60 x 24
      expireafter => "1400";

    dry_run|global_dry_run::
      action_policy => "warn";
}

####

body action warn_only
# @brief Warn once an hour if the promise needs to be repaired
#
# The promise does not get repaired.
{
      action_policy => "warn";
      ifelapsed => "60";
}

##

body action bg(elapsed,expire)
# @brief Evaluate the promise in the background every `elapsed` minutes, for at most `expire` minutes
# @param elapsed The time in minutes between promise evaluations
# @param expire The time in minutes after which a repair-attempt gets cancelled
{
      ifelapsed   => "$(elapsed)";
      expireafter => "$(expire)";
      background  => "true";

    dry_run|global_dry_run::
      action_policy => "warn";
}
##

body action immediate
# @brief Evaluate the promise at every `cf-agent` execution.
{
      ifelapsed => "0";

    dry_run|global_dry_run::
      action_policy => "warn";
}

##

body action policy(p)
# @brief Set the `action_policy` to `p`
# @param p The action policy
{
      action_policy => "$(p)";

    dry_run|global_dry_run::
      action_policy => "warn";
}
##
##-------------------------------------------------------
## classes
##-------------------------------------------------------

body classes if_else(yes,no)
# @brief Define the classes `yes` or `no` depending on promise outcome
# @param yes The name of the class that should be defined if the promise is kept or repaired
# @param no The name of the class that should be defined if the promise could not be repaired
{
      promise_kept     => { "$(yes)" };
      promise_repaired => { "$(yes)" };
      repair_failed    => { "$(no)" };
      repair_denied    => { "$(no)" };
      repair_timeout   => { "$(no)" };
}

##

body classes cf2_if_else(yes,no)
# @brief Define the classes `yes` or `no`, depending on promise outcome
#
# A version of `if_else` that matches CFEngine2 semantics. Neither class is set if the promise
# does not require any repair.
#
# @param yes The name of the class that should be defined if the promise is repaired
# @param no The name of the class that should be defined if the promise could not be repaired
{
      promise_repaired => { "$(yes)" };
      repair_failed    => { "$(no)" };
      repair_denied    => { "$(no)" };
      repair_timeout   => { "$(no)" };
}

##

body classes if_notkept(x)
# @brief Define the class `x` if the promise is not kept and cannot be repaired.
# @param x The name of the class that should be defined
{
      repair_failed   => { "$(x)" };
      repair_denied   => { "$(x)" };
      repair_timeout  => { "$(x)" };
}

##

body classes if_ok(x)
# @brief Define the class `x` if the promise is kept or repaired
# @param x The name of the class that should be defined
{
      promise_repaired => { "$(x)" };
      promise_kept => { "$(x)" };
}

##

body classes if_ok_cancel(x)
# @brief Cancel the class `x` if the promise is kept or repaired
# @param x The name of the class that should be cancelled
{
      cancel_repaired => { "$(x)" };
      cancel_kept => { "$(x)" };
}

##

body classes classes_generic(x)
# @brief Define `x` prefixed/suffixed with promise outcome
# @param x The unique part of the classes to be defined
{
      promise_repaired => { "promise_repaired_$(x)", "$(x)_repaired", "$(x)_ok", "$(x)_reached", "$(x)_not_kept" };
      repair_failed => { "repair_failed_$(x)", "$(x)_failed", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      repair_denied => { "repair_denied_$(x)", "$(x)_denied", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      repair_timeout => { "repair_timeout_$(x)", "$(x)_timeout", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      promise_kept => { "promise_kept_$(x)", "$(x)_kept", "$(x)_ok", "$(x)_not_repaired", "$(x)_reached" };
}
body classes scoped_classes_generic(scope, x)
# @brief Define `x` prefixed/suffixed with promise outcome
# **See also:** `scope`
#
# @param scope The scope in which the class should be defined
# @param x The unique part of the classes to be defined
{
      scope => "$(scope)";
      promise_repaired => { "promise_repaired_$(x)", "$(x)_repaired", "$(x)_ok", "$(x)_reached" };
      repair_failed => { "repair_failed_$(x)", "$(x)_failed", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      repair_denied => { "repair_denied_$(x)", "$(x)_denied", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      repair_timeout => { "repair_timeout_$(x)", "$(x)_timeout", "$(x)_not_ok", "$(x)_error", "$(x)_not_kept", "$(x)_not_repaired", "$(x)_reached" };
      promise_kept => { "promise_kept_$(x)", "$(x)_kept", "$(x)_ok", "$(x)_not_repaired", "$(x)_reached" };
}

##-------------------------------------------------------
## Persistent classes
##-------------------------------------------------------

body classes state_repaired(x)
# @brief Define `x` for 10 minutes if the promise was repaired
# @param x The name of the class that should be defined
{
      promise_repaired => { "$(x)" };
      persist_time => "10";
      scope => "namespace";
}

##

body classes enumerate(x)
# @brief Define `x` for 15 minutes if the promise is either kept or repaired
# This is used by commercial editions to count instances of jobs in a cluster
# @param x The unique part of the class that should be defined
# The class defined is prefixed with `mXC_`
{
      promise_repaired => { "mXC_$(x)" };
      promise_kept => { "mXC_$(x)" };
      persist_time => "15";
      scope => "namespace";
}

##

body classes always(x)
# @brief Define class `x` no matter what the outcome of the promise is
# @param x The name of the class to be defined
{
      promise_repaired => { "$(x)" };
      promise_kept => { "$(x)" };
      repair_failed => { "$(x)" };
      repair_denied => { "$(x)" };
      repair_timeout => { "$(x)" };
}

body classes kept_successful_command
# @brief Set command to "kept" instead of "repaired" if it returns 0
{
      kept_returncodes => { "0" };
}
