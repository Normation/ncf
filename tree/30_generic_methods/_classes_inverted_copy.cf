#####################################################################################
# Copyright 2014 Normation SAS
#####################################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, Version 3.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#####################################################################################

# @name Classes inverted copy
# @description Copy an inverted class prefix to another one, to switch the context from a bundle to another
#
# @parameter source_prefix      The prefix of the source class to copy
# @parameter destination_prefix The prefix of the destination class to copy
#
# @class_prefix
# @class_parameter
# This bundle will define a class ${destination_prefix}_{kept,repaired,error,ok,reached}
#Â based on an inverted ${source_prefix}_{kept,repaired,error,ok,reached}
#
# Conversion tables are:
#--------------------------------------------------
# KEPT CLASSES         <==>       REPAIRED CLASSES
#--------------------------------------------------
# promise_kept_class   <==> promise_repaired_class
# class_kept           <==> class_repaired
# class_not_repaired   <==> N/A
# class_ok             <==> class_ok
# class_reached        <==> class_reached
# -------------------------------------------------
#
#--------------------------------------------------
# ERROR CLASSES        <==>          ERROR CLASSES
#--------------------------------------------------
# repair_failed_class  <==> repair_failed_class
# repair_denied_class  <==> repair_denied_class
# repair_timeout_class <==> repair_timeout_class
# class_failed         <==> class_failed
# class_not_ok         <==> class_not_ok
# class_not_kept       <==> class_not_kept
# class_denied         <==> class_denied
# class_timeout        <==> class_timeout
# class_reached        <==> class_reached
#--------------------------------------------------

bundle agent _classes_inverted_copy(source_prefix, destination_prefix)
{
  vars:
      # Specify which are specific classes to kept or repaired
      "kept_prefix"                 slist => { "promise_kept" };
      "kept_suffix"                 slist => { "kept" };
      "repaired_prefix"             slist => { "promise_repaired" };
      "repaired_suffix"             slist => { "repaired" };
      "common_kept_repaired_suffix" slist => { "ok", "reached" };
      "error_prefix"                slist => { "repair_failed", "repair_denied", "repair_timeout" };
      "error_suffix"                slist => { "failed", "not_ok", "not_kept", "denied", "timeout" };
      "total_prefix"                slist => { "@{kept_prefix}", "@{repaired_prefix}", "@{error_prefix}" };
      "total_suffix"                slist => { "@{kept_suffix}", "@{repaired_suffix}", "@{common_kept_repaired_suffix}", "@{error_suffix}" };

    iteration1::
      # Copy not_repaired class, as it is a special case (only exists for error or kept, so kept classes are not exactly inverted repaired classes)
      "local_destination_prefix_not_repaired"
        string     => "${destination_prefix}_not_repaired",
        ifvarclass => "(${repaired_prefix}_${source_prefix}|${source_prefix}_${repaired_suffix})|(${error_prefix}_${source_prefix}|${source_prefix}_${error_suffix})",
        classes    => always("${destination_prefix}_not_repaired");

    iteration1.!source_class_error::
      # Copy common classes
      "local_destination_prefix_${common_kept_repaired_suffix}"
        string     => "${destination_prefix}_${common_kept_repaired_suffix}",
        ifvarclass => "${source_prefix}_${common_kept_repaired_suffix}",
        classes    => always("${destination_prefix}_${common_kept_repaired_suffix}");

      # Copy kept classes from repaired
      "${kept_prefix}_local_destination_prefix"
        string     => "${kept_prefix}_${destination_prefix}",
        ifvarclass => "${repaired_prefix}_${source_prefix}",
        classes    => always("${kept_prefix}_${destination_prefix}");
      "local_destination_prefix_${kept_suffix}"
        string     => "${destination_prefix}_${kept_suffix}",
        ifvarclass => "${source_prefix}_${repaired_suffix}",
        classes    => always("${destination_prefix}_${kept_suffix}");

      # Copy repaired classes from kept
      "${repaired_prefix}_local_destination_prefix"
        string     => "${repaired_prefix}_${destination_prefix}",
        ifvarclass => "${kept_prefix}_${source_prefix}",
        classes    => always("${repaired_prefix}_${destination_prefix}");
      "local_destination_prefix_${repaired_suffix}"
        string     => "${destination_prefix}_${repaired_suffix}",
        ifvarclass => "${source_prefix}_${kept_suffix}",
        classes    => always("${destination_prefix}_${repaired_suffix}");

      # Copy error classes (even if they should not exist)
      "${error_prefix}_local_destination_prefix"
        string     => "${error_prefix}_${destination_prefix}",
        ifvarclass => "${error_prefix}_${source_prefix}",
        classes    => always("${error_prefix}_${destination_prefix}");
      "local_destination_prefix_${error_suffix}"
        string     => "${destination_prefix}_${error_suffix}",
        ifvarclass => "${source_prefix}_${error_suffix}",
        classes    => always("${destination_prefix}_${error_suffix}");

    # If this is an error class, no inversion should be done but a simple copy
    iteration1.source_class_error::
      # Copy classes prefix
      "${total_prefix}_local_destination_prefix"
        string     => "${total_prefix}_${destination_prefix}",
        ifvarclass => "${total_prefix}_${source_prefix}",
        classes    => always("${total_prefix}_${destination_prefix}");

      # Copy classes suffix
      "local_destination_prefix_${total_suffix}"
        string     => "${destination_prefix}_${total_suffix}",
        ifvarclass => "${source_prefix}_${total_suffix}",
        classes    => always("${destination_prefix}_${total_suffix}");


  classes:
      "source_class_error" or => { classmatch("${source_prefix}_${error_suffix}"), classmatch("${error_prefix}_${source_prefix}") };
      "iteration1"         expression => "any";

}
