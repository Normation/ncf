#####################################################################################
# Copyright 2017 Normation SAS
#####################################################################################
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, Version 3.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#####################################################################################

# @name Variable string from command
# @description Define a variable from a command output
# @documentation Define a variable from a command output.
# The method will execute a shell command and define a variable `${prefix.name}` from it.
#
# * Only `stdout` is kept
# * The variable will only be defined if the exit code of the command is 0
# * If the variable definition is successful, the method will report a success, it will
# report an error otherwise.
# * The command will be executed even in *Audit mode*
#
# @parameter prefix The prefix of the variable name
# @parameter name   The variable to define, the full name will be prefix.name
# @parameter command         The command to execute
#
# @parameter_rename variable_prefix prefix
# @parameter_rename variable_name name
# @class_prefix variable_string_from_command
# @class_parameter name

bundle agent variable_string_from_command(prefix, name, command)
{
  vars:
      "old_class_prefix"  string => canonify("variable_string_from_command_${name}");
      "args"               slist => { "${prefix}", "${name}", "${command}" };
      "report_param"      string => join("_", args);
      "full_class_prefix" string => canonify("variable_string_from_command_${report_param}");
      "class_prefix"      string => string_head("${full_class_prefix}", "1000");

      "tmp_script_name"   string => "/var/rudder/tmp/${variable_prefix}_${variable_name}_${this.promiser_pid}";
      "c_tmp_script_name" string => canonify("${tmp_script_name}");
      "inner_class_prefix" string => "file_lines_present_${c_tmp_script_name}";

      # Why this ugly code? We need both the result and the return code of the command
      # and we would prefer only executing it once.
      #
      # To achieve this, we concatenate the return code as a three char string, and extract it afterwards.
      #
      # There are two little funny things there:
      # * the $() is considered an undefined variable, and the execresult is skipped. To avoid that,
      #   we add a /bin/true call, to trigger the "shell execution" case that skips undefined variable checks
      # * As verification is now skipped, we do not have to do it for ${OUTPUT}.
      #
      # The if is necessary to avoid evaluating the command in cf-promises,
      # for example when checking promises on the server.

      "temp"     string => execresult("OUTPUT=${const.dollar}(/bin/true; 2>/dev/null ${tmp_script_name}); printf \"%3d\" ${const.dollar}?; echo \"${const.dollar}OUTPUT\"", "useshell"),
                     if => "${inner_class_prefix}_ok";
      "temp_length" int => string_length("${temp}"),
                     if => "${inner_class_prefix}_ok";
      "raw_output_length" string => eval("${temp_length} - 3", "math", "infix"),
                     if => "${inner_class_prefix}_ok";
      "output_length" string => format("%d", "${raw_output_length}"),
                     if => "${inner_class_prefix}_ok";
      "raw_code" string => string_head("${temp}", "3"),
                     if => "${inner_class_prefix}_ok";
      "code" string => format("%d", "${raw_code}"),
                     if => "${inner_class_prefix}_ok";

      # define the variable within the prefix namespace
    pass2::
      "${prefix}.${name}" string =>  string_tail("${temp}", "${output_length}"),
                                        ifvarclass => "returned_zero";

  classes:
      "should_report"     expression => "${report_data.should_report}";
    pass1::
      "returned_zero"     expression => strcmp("${code}", "0");
    pass2::
      "variable_defined" expression => isvariable("${prefix}.${name}");

    any::
      "pass3" expression => "pass2";
      "pass2" expression => "pass1";
      "pass1" expression => "any";

  methods:
      # In audit mode, we need to force enforce mode to set and remove the temp files.
      "remove_dry_run_mode_${class_prefix}" usebundle => push_dry_run_mode("false");

      "disable_reporting_${class_prefix}"
                 usebundle => disable_reporting;
      # put the command in a script, and make it executable
      "script_${class_prefix}"
                 usebundle => file_content("${tmp_script_name}", "${command}", "true");
      "perms_${class_prefix}"
                 usebundle => permissions("${tmp_script_name}", "700", "root", "0");
    pass3.!variable_defined::
      "error"    usebundle => _classes_failure("${old_class_prefix}");
      "error"    usebundle => _classes_failure("${class_prefix}");

    pass3.variable_defined::
      "success"  usebundle => _classes_success("${old_class_prefix}");
      "success"  usebundle => _classes_success("${class_prefix}");

    pass3::
      "clean_${class_prefix}"
                 usebundle => file_absent("${tmp_script_name}");

      "restore dry-run_${class_prefix}"
                 usebundle => pop_dry_run_mode();

      "reenable_reporting_${class_prefix}"
         usebundle => enable_reporting,
                if => "should_report";

      "report"
        usebundle  => _log_v3("Set the string ${prefix}.${name} to the output of '${command}'", "${name}", "${old_class_prefix}", "${class_prefix}", @{args});


  reports:
    pass3.info.returned_zero::
      "The '${command}' command returned '${${prefix}.${name}}'";
    pass3.info.!returned_zero::
      "The '${command}' command failed with ${code} code";

}
