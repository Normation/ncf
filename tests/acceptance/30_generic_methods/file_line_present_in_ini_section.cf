#######################################################
#
# Test checking if a line is present in a section file
#
#######################################################

bundle common acc_path
{
  vars:
    "root" string => getenv("NCF_TESTS_ACCEPTANCE", 1024);
}

body common control
{
      inputs => { "${acc_path.root}/default.cf.sub", "${acc_path.root}/default_ncf.cf.sub", "@{ncf_inputs.default_files}" };
      bundlesequence  => { configuration, default("${this.promise_filename}") };
      version => "1.0";
}

#######################################################
bundle agent init
{
  vars:
    "tmp"         string => getenv("TEMP", 1024);

  ## REPAIRED
    # Simple addition
    "file[0]"     string => "${tmp}/test0.ini";
    "section[0]"  string => "section1";
    "line[0]"     string => "bar";
    "status[0]"   string => "repaired";
    "initial[0]"  string => "[section1]
foo";
    "expected[0]" string => "[section1]
foo
bar";

    # Simple addition in middle section
    "file[1]"     string => "${tmp}/test1.ini";
    "section[1]"  string => "section1";
    "line[1]"     string => "bar";
    "status[1]"   string => "repaired";
    "initial[1]"  string => "[section0]
some nice content
[section1]
foo
[section2]
foobar";
    "expected[1]" string => "[section0]
some nice content
[section1]
foo
bar
[section2]
foobar";

    # Simple addition in middle section with line already present in other sections
    "file[2]"     string => "${tmp}/test2.ini";
    "section[2]"  string => "section1";
    "line[2]"     string => "bar";
    "status[2]"   string => "repaired";
    "initial[2]"  string => "[section0]
some nice content
bar
[section1]
foo
[section2]
foobar";
    "expected[2]" string => "[section0]
some nice content
bar
[section1]
foo
bar
[section2]
foobar";

    # Simple addition with undefined section and content in other sections
    "file[3]"     string => "${tmp}/test3.ini";
    "section[3]"  string => "new_section";
    "line[3]"     string => "bar
foobar";
    "status[3]"   string => "repaired";
    "initial[3]"  string => "[section1]
foo
bar
foobar";
    "expected[3]" string => "[section1]
foo
bar
foobar
[new_section]
bar
foobar";

    # Simple addition with empty last section
    "file[4]"     string => "${tmp}/test4.ini";
    "section[4]"  string => "section1";
    "line[4]"     string => "foo
foo
bar
foobar";
    "status[4]"   string => "repaired";
    "initial[4]"  string => "[section1]";
    "expected[4]" string => "[section1]
foo
bar
foobar";

  ## SUCCESS (same than above)
    "file[5]"     string => "${tmp}/test5.ini";
    "section[5]"  string => "section1";
    "line[5]"     string => "bar";
    "status[5]"   string => "success";
    "initial[5]"  string => "[section1]
foo
bar";
    "expected[5]" string => "${initial[5]}";

    "file[6]"     string => "${tmp}/test6.ini";
    "section[6]"  string => "section1";
    "line[6]"     string => "bar";
    "status[6]"   string => "success";
    "initial[6]"  string => "[section0]
some nice content
[section1]
foo
bar
[section2]
foobar";
    "expected[6]" string => "${initial[6]}";

    "file[7]"     string => "${tmp}/test7.ini";
    "section[7]"  string => "section1";
    "line[7]"     string => "bar";
    "status[7]"   string => "success";
    "initial[7]"  string => "[section0]
some nice content
bar
[section1]
foo
bar
[section2]
foobar";
    "expected[7]" string => "${initial[7]}";

    "file[8]"     string => "${tmp}/test8.ini";
    "section[8]"  string => "new_section";
    "line[8]"     string => "bar
foobar";
    "status[8]"   string => "success";
    "initial[8]"  string => "[section1]
foo
[new_section]
bar
foobar";
    "expected[8]" string => "${initial[8]}";

    "file[9]"     string => "${tmp}/test9.ini";
    "section[9]"  string => "section1";
    "line[9]"     string => "foo
bar
foobar";
    "status[9]"   string => "success";
    "initial[9]"  string => "[section1]
foo
bar
foobar";
    "expected[9]" string => "${initial[9]}";


  ## Others
  # In a non existing file
    "file[10]"     string => "${tmp}/test10.ini";
    "section[10]"  string => "section1";
    "line[10]"     string => "bar";
    "status[10]"   string => "repaired";
    "expected[10]" string => "[section1]
bar";

  # Add a section using the method
  # then add a line under it
  # The expected part is the same as the on in the next test
    "file[11]"     string => "${tmp}/test11.ini";
    "section[11]"  string => "section1";
    "line[11]"     string => "[section2]";
    "status[11]"   string => "repaired";
    "initial[11]"  string => "[section1]";
    "expected[11]" string => "[section1]
[section2]
foo";
    "file[12]"     string => "${tmp}/test11.ini";
    "section[12]"  string => "section2";
    "line[12]"     string => "foo";
    "status[12]"   string => "repaired";
    "initial[12]"  string => "[section1]";
    "expected[12]" string => "[section1]
[section2]
foo";

    # Simple addition with empty last section and existing content
    "file[13]"     string => "${tmp}/test13.ini";
    "section[13]"  string => "section1";
    "line[13]"     string => "foo
bar
foobar";
    "status[13]"   string => "repaired";
    "initial[13]"  string => "[section0]
foobar
bar
foo
[section1]";
    "expected[13]" string => "${initial[13]}
foo
bar
foobar";

    "indices"     slist => getindices("status");

  files:
    "${file[${indices}]}"
      create => "true",
      edit_line => insert_lines("${initial[${indices}]}"),
      edit_defaults => empty,
      unless => strcmp("${indices}", "10");
}

#######################################################

bundle agent test
{
  vars:
    "args${init.indices}" slist => { "${init.file[${init.indices}]}", "${init.section[${init.indices}]}", "${init.line[${init.indices}]}" };

  methods:
    # Enforce
    "ph0" usebundle  => apply_gm("file_line_present_in_ini_section", @{args0}, "${init.status[0]}", "ph0", "enforce" );
    "ph1" usebundle  => apply_gm("file_line_present_in_ini_section", @{args1}, "${init.status[1]}", "ph1", "enforce" );
    "ph2" usebundle  => apply_gm("file_line_present_in_ini_section", @{args2}, "${init.status[2]}", "ph2", "enforce" );
    "ph3" usebundle  => apply_gm("file_line_present_in_ini_section", @{args3}, "${init.status[3]}", "ph3", "enforce" );
    "ph4" usebundle  => apply_gm("file_line_present_in_ini_section", @{args4}, "${init.status[4]}", "ph4", "enforce" );
    "ph5" usebundle  => apply_gm("file_line_present_in_ini_section", @{args5}, "${init.status[5]}", "ph5", "enforce" );
    "ph6" usebundle  => apply_gm("file_line_present_in_ini_section", @{args6}, "${init.status[6]}", "ph6", "enforce" );
    "ph7" usebundle  => apply_gm("file_line_present_in_ini_section", @{args7}, "${init.status[7]}", "ph7", "enforce" );
    "ph8" usebundle  => apply_gm("file_line_present_in_ini_section", @{args8}, "${init.status[8]}", "ph8", "enforce" );
    "ph9" usebundle  => apply_gm("file_line_present_in_ini_section", @{args9}, "${init.status[9]}", "ph9", "enforce" );
    "ph10" usebundle  => apply_gm("file_line_present_in_ini_section", @{args10}, "${init.status[10]}", "ph10", "enforce" );
    "ph11" usebundle  => apply_gm("file_line_present_in_ini_section", @{args11}, "${init.status[11]}", "ph11", "enforce" );
    "ph12" usebundle  => apply_gm("file_line_present_in_ini_section", @{args12}, "${init.status[12]}", "ph12", "enforce" );
    "ph13" usebundle  => apply_gm("file_line_present_in_ini_section", @{args13}, "${init.status[13]}", "ph13", "enforce" );
}

#######################################################

bundle agent check
{
  vars:
    pass1::
      "indices" slist => { @{init.indices} };
      # function readfile adds an extra trailing newline if there is no trailing newline, too inconsistent
      "content[${indices}]" string => execresult("${paths.cat} ${init.file[${indices}]}", "noshell");

  classes:
      "pass3" expression => "pass2";
      "pass2" expression => "pass1";
      "pass1" expression => "any";

    pass2::
      "content_ok_${indices}" expression => and(
                                            strcmp("${content[${indices}]}", "${init.expected[${indices}]}"),
                                            fileexists("${init.file[${indices}]}")
                                          );

      "content_not_ok" expression => "!content_ok_${indices}";
      "classes_ok"     expression => "ph0_ok.ph1_ok.ph2_ok.ph3_ok.ph4_ok.ph5_ok.ph6_ok.ph7_ok.ph8_ok.ph9_ok.ph10_ok.ph11_ok.ph12_ok.ph13_ok";
      "ok"             expression => "!content_not_ok.classes_ok";


  reports:
    pass3::
      "###########################
ERROR test ${indices} in
${init.file[${indices}]}
EXPECTED:
${init.expected[${indices}]}
---------------------------
FOUND:
${content[${indices}]}
###########################"
         ifvarclass => "!content_ok_${indices}";

    pass3.ok::
      "$(this.promise_filename) Pass";
    pass3.!ok::
      "$(this.promise_filename) FAIL";
}

